<!-- websockets.html -->

<img src="assets/flag.png" hidden />
<img src="assets/bomb.png" hidden />
<div id="map">
  <canvas id="map_canvas"></canvas>
  <canvas id="interaction_canvas"></canvas>
</div>

<style>
  #map {
    position: relative;
  }
  #map canvas {
    position: absolute;
    top: 0;
    left: 0;
  }
</style>
<script defer async>
  const FLAG = 63;
  const BOMB = 33;
  const COVERED = 35;
  const EMPTY = 0;
  const fieldSize = 20;
  const IMAGES = [];
  {
    // prepare text images
    const offscreen = new OffscreenCanvas(fieldSize, fieldSize);
    const oContext = offscreen.getContext("2d");
    oContext.fillStyle = "black";
    oContext.font = `${fieldSize}px consolas`;
    oContext.textAlign = "center";
    oContext.textBaseline = "middle";
    for (let i = 0; i < 10; i++) {
      oContext.fillText(i, fieldSize / 2, fieldSize / 2);
      const bmp = offscreen.transferToImageBitmap();
      IMAGES[i] = bmp;
    }
    {
      const flag = new Image();
      flag.src = "./assets/flag.png";
      IMAGES[FLAG] = flag;
    }
    {
      const bomb = new Image();
      bomb.src = "./assets/bomb.png";
      IMAGES[BOMB] = bomb;
    }
    {
      oContext.fillStyle = "darkgreen";
      oContext.fillRect(0, 0, fieldSize, fieldSize);
      const empty = offscreen.transferToImageBitmap();
      IMAGES[COVERED] = empty;
    }
  }

  const MOUSE = {
    rawX: 0,
    rawY: 0,
    canvasX: 0,
    canvasY: 0,
    fieldX: 0,
    fieldY: 0,
  };
  const input = document.getElementById("input");
  const output = document.getElementById("output");
  const map_canvas = document.getElementById("map_canvas");
  const interaction_canvas = document.getElementById("interaction_canvas");
  interaction_canvas.addEventListener("mousemove", (e) => {
    e.preventDefault();
    MOUSE.rawX = e.offsetX;
    MOUSE.rawY = e.offsetY;
    MOUSE.canvasX =
      Math.round((MOUSE.rawX - fieldSize / 2) / fieldSize) * fieldSize;
    MOUSE.canvasY =
      Math.round((MOUSE.rawY - fieldSize / 2) / fieldSize) * fieldSize;
    MOUSE.fieldX = Math.round(MOUSE.canvasX / fieldSize);
    MOUSE.fieldY = Math.round(MOUSE.canvasY / fieldSize);
  });
  interaction_canvas.addEventListener("click", (e) => {
    e.preventDefault();
    const idx = MOUSE.fieldX + mapMetadata.width * MOUSE.fieldY;
    sendUncover(idx);
  });
  interaction_canvas.addEventListener("contextmenu", (e) => {
    e.preventDefault();
    const idx = MOUSE.fieldX + mapMetadata.width * MOUSE.fieldY;
    console.table(MOUSE);
    sendMark(idx);
  });
  /**
   * @type {CanvasRenderingContext2D}
   */
  let mapContext;
  /**
   * @type {CanvasRenderingContext2D}
   */
  let interactionContext;
  mapContext = map_canvas.getContext("2d");
  mapContext.textAlign = "center";
  mapContext.textBaseline = "middle";
  interactionContext = interaction_canvas.getContext("2d");

  let MAP_ARR = new Uint8Array();

  const mapMetadata = {
    width: 0,
    height: 0,
  };

  function byteToStyle(byte) {
    if (byte == EMPTY) return "grey";
    if (byte == COVERED) return "darkgreen";
    if (byte == FLAG) return "darkgreen";
    if (byte == BOMB) return "red";
    return "yellow";
  }

  const socket = new WebSocket("ws://localhost:8080/echo");

  socket.binaryType = "arraybuffer";
  socket.onopen = function () {};

  socket.onmessage = async function (event) {
    if (event.data[0] == "w") {
      const data = event.data.split(":");
      mapMetadata.width = Number(data[1]);
      mapMetadata.height = Number(data[2]);
      const { width, height } = mapMetadata;
      map_canvas.width = width * fieldSize;
      map_canvas.height = height * fieldSize;
      interaction_canvas.width = width * fieldSize;
      interaction_canvas.height = height * fieldSize;

      MAP_ARR = new Uint8Array(width * height);
    } else if (event.data instanceof ArrayBuffer) {
      const view = new DataView(event.data);
      // console.log(view.getUint8(0))
      // console.log(view.byteLength)
      if (view.getUint8(0) == 109) {
        const arr = new Uint8Array(view.buffer.slice(1));
        arr.forEach((v, i) => (MAP_ARR[i] = v));
        drawOriginalMap();
        interactionDraw();
      } else if (view.getInt8(0) == 117) {
        const changes = new BigUint64Array(view.buffer.slice(1));
        const toUpdate = [];
        for (let i = 0; i < changes.length; i += 2) {
          MAP_ARR[Number(changes[i])] = Number(changes[i + 1]);
          toUpdate.push(Number(changes[i]));
        }
        redraw(toUpdate);
      }
    } else {
      output.innerHTML += "Server: " + e.data + "\n";
    }
  };

  function drawOriginalMap() {
    for (let y = 0; y < mapMetadata.height; y++) {
      for (let x = 0; x < mapMetadata.width; x++) {
        const byte = MAP_ARR[x + mapMetadata.width * y];
        mapContext.fillStyle = byteToStyle(byte);
        mapContext.fillRect(x * fieldSize, y * fieldSize, fieldSize, fieldSize);

        if (byte > 0)
          mapContext.drawImage(IMAGES[byte], x * fieldSize, y * fieldSize);
      }
    }
  }

  /**
   * @param {number[]} toUpdate
   */
  function redraw(toUpdate) {
    console.table(toUpdate);
    toUpdate.forEach((idx) => {
      const byte = MAP_ARR[idx];
      const x = Math.floor(idx % mapMetadata.width);
      const y = Math.floor(idx / mapMetadata.height);
      mapContext.fillStyle = byteToStyle(byte);
      mapContext.fillRect(x * fieldSize, y * fieldSize, fieldSize, fieldSize);

      if (byte > 0)
        mapContext.drawImage(IMAGES[byte], x * fieldSize, y * fieldSize);
    });
  }

  function interactionDraw() {
    interactionContext.clearRect(
      0,
      0,
      interaction_canvas.width,
      interaction_canvas.height
    );
    interactionContext.fillStyle = "red";
    interactionContext.fillRect(
      MOUSE.canvasX,
      MOUSE.canvasY,
      fieldSize,
      fieldSize
    );
    requestAnimationFrame(interactionDraw);
  }

  function sendUncover(idx) {
    socket.send("u" + idx);
  }

  function sendMark(idx) {
    socket.send("m" + idx);
  }
</script>
